#version 410
layout (location = 0) in vec3 VertexPosition;
layout (location = 1) in vec3 VertexNormal;
layout (location = 2) in vec2 VertexTexCoord;

out vec4 EyePosition;
out vec3 TNormal;
out vec2 TexCoord;

// Coordinate to be used for shadow map lookup 
out vec4 ShadowCoord[2];

out vec3 ambient;
out vec3 diffAndSpec;

uniform sampler2D BumpMap;
uniform sampler2D SpecMap;

//Matrices-----------------------------------------
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ProjectionMatrix;		   
uniform mat4 ShadowMatrix[2];

vec3 normal;

struct LightInfo{
	vec4 Position; // Light position world coords.
	vec3 Intensity; // La, Ld and Ls intensity
	vec3 Color;
	float Distance;
};
uniform LightInfo Lights[2];

struct MaterialInfo{
	vec3 Ka;			// Ambient reflectivity
	vec3 Kd;		    // Diffuse reflectivity
	vec3 Ks;			// Specular reflectivity
	float Shininess;	// Specular shininess factor
};
uniform MaterialInfo Material;

vec3 phongModelDiffAndSpec(int index, vec3 lightPos, float strength) {

	vec3 s = normalize(vec3(lightPos - EyePosition));
	vec3 v = normalize(-EyePosition.xyz);	
	vec3 r = reflect( -s, normal );

	float sDotN = max( dot(s, normal), 0.0 );
	
	//Diffuse light
	vec3 diffuse = vec3(Lights[index].Intensity.y) * Lights[index].Color * Material.Kd * sDotN * strength;

	vec3 Ks = Material.Ks;

	//if(texture(SpecMap, TexCoord) != vec4(0.0))
	//{
	//	Ks = texture(SpecMap, TexCoord).xyz;
	//}

	vec3 specular = vec3(0.0);
	
	//Specular light
	if( sDotN > 0.0 )
		specular = vec3(Lights[index].Intensity.z) * Lights[index].Color * Ks * pow( max( dot(r,v), 0.0 ), Material.Shininess ) * strength;
		
	return vec3(diffuse + specular);
}

void main()
{
	TexCoord = VertexTexCoord;
	TNormal = normalize(NormalMatrix * VertexNormal);
	mat4 ModelViewMatrix = ViewMatrix * ModelMatrix;
	EyePosition = ModelViewMatrix * vec4(VertexPosition,1.0);
	
	mat4 MVP = ProjectionMatrix * ModelViewMatrix;

	// ShadowMatrix converts from modeling coordinates to shadow map coordinates.  
	for(int i = 0; i < 2; i++)
	{
		ShadowCoord[i] = ShadowMatrix[i] * vec4(VertexPosition,1.0);
	}

	//if(texture(BumpMap, TexCoord) != vec4(0.0))
	//{
	//	vec4 norm = texture(BumpMap, TexCoord);
	//	normal.x = 2 * (norm.x - 0.5);
	//	normal.y = 2 * (norm.y - 0.5);
//		normal.z = 2 * (norm.z - 0.5);
//	}
//	else
		normal = TNormal;

//--------Light calculations--------------------------------------------------------------
	ambient = vec3(Lights[0].Intensity.x) * Material.Ka;

	diffAndSpec = vec3(0.0);

	for(int i = 0; i < 2; i++)
	{
		vec4 LightWPosition = ViewMatrix * Lights[i].Position;

		vec4 tempVec = (ModelViewMatrix * vec4(VertexPosition,1.0)) - LightWPosition;
		float lightDist = abs(length(tempVec));
		float lightStrength = 0;
		if( lightDist < Lights[i].Distance )
			lightStrength = 1.0-(lightDist / Lights[i].Distance);
		
		//för alla ljus
		diffAndSpec += phongModelDiffAndSpec(i, LightWPosition, lightStrength);
	}
	
//----------------------------------------------------------------------------------------

	gl_Position = MVP * vec4(VertexPosition,1.0);
}